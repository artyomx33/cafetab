'use client'

import { useState, useEffect, useCallback } from 'react'
import { createClient } from './client'
import type {
  Seller,
  Tab,
  TabItem,
  Product,
  Category,
  Table,
  Order,
  OrderItem,
  Notification,
  TabWithItems as TabWithItemsType,
  CategoryWithProducts as CategoryWithProductsType,
  TableWithTab,
  OrderWithItems,
  NotificationWithTable
} from '@/types'

// Re-export types from @/types
export type { TabWithItemsType as TabWithItems, CategoryWithProductsType as CategoryWithProducts }

const supabase = createClient()

// Seller hooks
export function useVerifyPin() {
  const [loading, setLoading] = useState(false)
  const [error, setError] = useState<string | null>(null)

  const verify = useCallback(async (pin: string): Promise<Seller | null> => {
    setLoading(true)
    setError(null)

    const pinHash = `hashed_${pin}`
    const { data, error: err } = await supabase
      .from('cafe_sellers')
      .select('*')
      .eq('pin_hash', pinHash)
      .eq('is_active', true)
      .single()

    if (err || !data) {
      setError('Invalid PIN')
      setLoading(false)
      return null
    }

    setLoading(false)
    return data as Seller
  }, [])

  return { verify, loading, error }
}

// Table hooks (replaces Groups)
export function useTables() {
  const [tables, setTables] = useState<TableWithTab[]>([])
  const [loading, setLoading] = useState(true)

  const refresh = useCallback(async () => {
    const { data: tablesData } = await supabase
      .from('cafe_tables')
      .select(`
        *,
        cafe_tabs!current_tab_id (*)
      `)
      .order('number', { ascending: true })

    if (tablesData) {
      const formatted = tablesData.map((t: any) => ({
        id: t.id,
        number: t.number,
        qr_code: t.qr_code,
        status: t.status,
        section: t.section,
        current_tab_id: t.current_tab_id,
        created_at: t.created_at,
        current_tab: t.cafe_tabs || null
      }))
      setTables(formatted)
    }
    setLoading(false)
  }, [])

  useEffect(() => {
    refresh()
  }, [refresh])

  return { tables, loading, refresh }
}

export function useTableByQR(qrCode: string) {
  const [table, setTable] = useState<Table | null>(null)
  const [tab, setTab] = useState<TabWithItemsType | null>(null)
  const [loading, setLoading] = useState(true)
  const [error, setError] = useState<string | null>(null)

  const refresh = useCallback(async () => {
    if (!qrCode) {
      setLoading(false)
      return
    }

    const { data: tableData, error: err } = await supabase
      .from('cafe_tables')
      .select('*')
      .eq('qr_code', qrCode)
      .single()

    if (err || !tableData) {
      setError('Table not found')
      setLoading(false)
      return
    }

    setTable(tableData as Table)

    // Get current tab with items if exists
    if (tableData.current_tab_id) {
      const { data: tabData } = await supabase
        .from('cafe_tabs')
        .select(`
          *,
          cafe_tab_items (
            *,
            cafe_products (*)
          )
        `)
        .eq('id', tableData.current_tab_id)
        .single()

      if (tabData) {
        const tabWithItems: TabWithItemsType = {
          id: tabData.id,
          table_id: tabData.table_id,
          type: tabData.type,
          status: tabData.status,
          total: tabData.total,
          prepaid_amount: tabData.prepaid_amount,
          balance: tabData.balance,
          tip: tabData.tip,
          paid_at: tabData.paid_at,
          created_by: tabData.created_by,
          created_at: tabData.created_at,
          tab_items: tabData.cafe_tab_items?.map((item: any) => ({
            id: item.id,
            tab_id: item.tab_id,
            product_id: item.product_id,
            seller_id: item.seller_id,
            order_id: item.order_id,
            quantity: item.quantity,
            unit_price: item.unit_price,
            created_at: item.created_at,
            product: item.cafe_products
          })) || []
        }
        setTab(tabWithItems)
      }
    }

    setError(null)
    setLoading(false)
  }, [qrCode])

  useEffect(() => {
    refresh()
  }, [refresh])

  return { table, tab, loading, error, refresh }
}

export function useTableById(id: string) {
  const [table, setTable] = useState<Table | null>(null)
  const [loading, setLoading] = useState(true)

  useEffect(() => {
    if (!id) {
      setLoading(false)
      return
    }

    const fetchTable = async () => {
      const { data } = await supabase
        .from('cafe_tables')
        .select('*')
        .eq('id', id)
        .single()

      setTable(data as Table)
      setLoading(false)
    }

    fetchTable()
  }, [id])

  return { table, loading }
}

export function useCreateTable() {
  const [loading, setLoading] = useState(false)

  const create = useCallback(async (number: string, section?: string): Promise<Table> => {
    setLoading(true)

    // Generate unique QR code
    const qrCode = `TBL-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`

    const { data: table, error } = await supabase
      .from('cafe_tables')
      .insert({
        number,
        qr_code: qrCode,
        status: 'available',
        section: section || null,
        current_tab_id: null
      })
      .select()
      .single()

    if (error) throw error

    setLoading(false)
    return table as Table
  }, [])

  return { create, loading }
}

// Categories & Products hooks
export function useCategories() {
  const [categories, setCategories] = useState<CategoryWithProductsType[]>([])
  const [loading, setLoading] = useState(true)

  useEffect(() => {
    const fetchCategories = async () => {
      const { data } = await supabase
        .from('cafe_categories')
        .select(`
          *,
          cafe_products (*)
        `)
        .eq('is_visible', true)
        .order('sort_order')

      if (data) {
        const formatted = data.map((cat: any) => ({
          id: cat.id,
          name: cat.name,
          sort_order: cat.sort_order,
          is_visible: cat.is_visible,
          created_at: cat.created_at,
          products: (cat.cafe_products || [])
            .filter((p: Product) => p.is_active)
            .sort((a: Product, b: Product) => a.sort_order - b.sort_order)
        }))
        setCategories(formatted)
      }
      setLoading(false)
    }

    fetchCategories()
  }, [])

  return { categories, loading }
}

// Tab hooks
export function useTab(tableId: string) {
  const [tab, setTab] = useState<TabWithItemsType | null>(null)
  const [loading, setLoading] = useState(true)

  const refresh = useCallback(async () => {
    const { data: tabData } = await supabase
      .from('cafe_tabs')
      .select(`
        *,
        cafe_tab_items (
          *,
          cafe_products (*)
        )
      `)
      .eq('table_id', tableId)
      .eq('status', 'open')
      .single()

    if (tabData) {
      const tabWithItems: TabWithItemsType = {
        id: tabData.id,
        table_id: tabData.table_id,
        type: tabData.type,
        status: tabData.status,
        total: tabData.total,
        prepaid_amount: tabData.prepaid_amount,
        balance: tabData.balance,
        tip: tabData.tip,
        paid_at: tabData.paid_at,
        created_by: tabData.created_by,
        created_at: tabData.created_at,
        tab_items: tabData.cafe_tab_items?.map((item: any) => ({
          id: item.id,
          tab_id: item.tab_id,
          product_id: item.product_id,
          seller_id: item.seller_id,
          order_id: item.order_id,
          quantity: item.quantity,
          unit_price: item.unit_price,
          created_at: item.created_at,
          product: item.cafe_products
        })) || []
      }
      setTab(tabWithItems)
    }
    setLoading(false)
  }, [tableId])

  useEffect(() => {
    refresh()
  }, [refresh])

  const addItem = useCallback(async (productId: string, quantity: number, sellerId?: string, orderId?: string) => {
    if (!tab) return null

    // Get product price
    const { data: product } = await supabase
      .from('cafe_products')
      .select('price')
      .eq('id', productId)
      .single()

    if (!product) return null

    const { data: item, error } = await supabase
      .from('cafe_tab_items')
      .insert({
        tab_id: tab.id,
        product_id: productId,
        seller_id: sellerId || null,
        order_id: orderId || null,
        quantity,
        unit_price: product.price
      })
      .select()
      .single()

    if (error) throw error

    refresh()
    return item
  }, [tab, refresh])

  const removeItem = useCallback(async (itemId: string) => {
    await supabase
      .from('cafe_tab_items')
      .delete()
      .eq('id', itemId)

    refresh()
  }, [refresh])

  const markPaid = useCallback(async () => {
    if (!tab) return false

    const { error } = await supabase
      .from('cafe_tabs')
      .update({
        status: 'paid',
        paid_at: new Date().toISOString()
      })
      .eq('id', tab.id)

    // Update table status to available
    await supabase
      .from('cafe_tables')
      .update({
        status: 'available',
        current_tab_id: null
      })
      .eq('id', tab.table_id)

    refresh()
    return !error
  }, [tab, refresh])

  return { tab, loading, refresh, addItem, removeItem, markPaid }
}

// Admin hooks
export function useDashboardStats() {
  const [stats, setStats] = useState({ totalSales: 0, totalTables: 0, occupiedTables: 0, openTabs: 0 })
  const [leaderboard, setLeaderboard] = useState<{ id: string; name: string; itemsSold: number; totalSales: number }[]>([])
  const [activity, setActivity] = useState<{ id: string; productName: string; quantity: number; total: number; sellerName: string; tableName: string; createdAt: string }[]>([])
  const [loading, setLoading] = useState(true)

  const refresh = useCallback(async () => {
    // Get tables stats
    const { count: totalTables } = await supabase
      .from('cafe_tables')
      .select('*', { count: 'exact', head: true })

    const { count: occupiedTables } = await supabase
      .from('cafe_tables')
      .select('*', { count: 'exact', head: true })
      .eq('status', 'occupied')

    // Get open tabs count
    const { count: openTabs } = await supabase
      .from('cafe_tabs')
      .select('*', { count: 'exact', head: true })
      .eq('status', 'open')

    // Get today's revenue (paid tabs from today)
    const today = new Date()
    today.setHours(0, 0, 0, 0)
    const { data: todayTabs } = await supabase
      .from('cafe_tabs')
      .select('total')
      .eq('status', 'paid')
      .gte('paid_at', today.toISOString())

    const totalSales = todayTabs?.reduce((sum, t) => sum + Number(t.total), 0) || 0

    setStats({
      totalSales,
      totalTables: totalTables || 0,
      occupiedTables: occupiedTables || 0,
      openTabs: openTabs || 0
    })

    // Get seller leaderboard
    const { data: sellers } = await supabase
      .from('cafe_sellers')
      .select('id, name')
      .eq('is_active', true)

    if (sellers) {
      const sellerStats = await Promise.all(
        sellers.map(async (seller) => {
          const { data: items } = await supabase
            .from('cafe_tab_items')
            .select('quantity, unit_price')
            .eq('seller_id', seller.id)

          const itemsSold = items?.reduce((sum, i) => sum + i.quantity, 0) || 0
          const totalSales = items?.reduce((sum, i) => sum + (i.quantity * Number(i.unit_price)), 0) || 0

          return {
            id: seller.id,
            name: seller.name,
            itemsSold,
            totalSales
          }
        })
      )
      setLeaderboard(sellerStats.sort((a, b) => b.totalSales - a.totalSales))
    }

    // Get recent activity
    const { data: recentItems } = await supabase
      .from('cafe_tab_items')
      .select(`
        id,
        quantity,
        unit_price,
        created_at,
        cafe_products (name),
        cafe_sellers (name),
        cafe_tabs (cafe_tables (number))
      `)
      .order('created_at', { ascending: false })
      .limit(10)

    if (recentItems) {
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      const activityData = recentItems.map((item: any) => ({
        id: item.id,
        productName: item.cafe_products?.name || 'Unknown',
        quantity: item.quantity,
        total: item.quantity * Number(item.unit_price),
        sellerName: item.cafe_sellers?.name || 'Unknown',
        tableName: item.cafe_tabs?.cafe_tables?.number ? `Table ${item.cafe_tabs.cafe_tables.number}` : 'Unknown',
        createdAt: item.created_at
      }))
      setActivity(activityData)
    }

    setLoading(false)
  }, [])

  useEffect(() => {
    refresh()
  }, [refresh])

  return { stats, leaderboard, activity, loading, refresh }
}

export function useAllGroups() {
  const [groups, setGroups] = useState<(Group & { total: number })[]>([])
  const [loading, setLoading] = useState(true)

  const refresh = useCallback(async () => {
    const { data } = await supabase
      .from('golf_groups')
      .select(`
        *,
        golf_tabs (total)
      `)
      .order('created_at', { ascending: false })

    if (data) {
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      const groupsWithTotal = data.map((g: any) => ({
        ...g,
        total: g.golf_tabs?.[0]?.total || 0
      }))
      setGroups(groupsWithTotal)
    }
    setLoading(false)
  }, [])

  useEffect(() => {
    refresh()
  }, [refresh])

  return { groups, loading, refresh }
}

export function useAllProducts() {
  const [products, setProducts] = useState<Product[]>([])
  const [categories, setCategories] = useState<Category[]>([])
  const [loading, setLoading] = useState(true)

  const refresh = useCallback(async () => {
    const { data: productsData } = await supabase
      .from('cafe_products')
      .select('*')
      .order('sort_order')

    const { data: categoriesData } = await supabase
      .from('cafe_categories')
      .select('*')
      .order('sort_order')

    setProducts(productsData || [])
    setCategories(categoriesData || [])
    setLoading(false)
  }, [])

  useEffect(() => {
    refresh()
  }, [refresh])

  const createProduct = useCallback(async (data: { name: string; price: number; category_id: string; description?: string }) => {
    const { data: product, error } = await supabase
      .from('cafe_products')
      .insert({
        ...data,
        is_active: true,
        sort_order: 0
      })
      .select()
      .single()

    if (error) throw error
    refresh()
    return product
  }, [refresh])

  const updateProduct = useCallback(async (id: string, data: Partial<Product>) => {
    const { data: product, error } = await supabase
      .from('cafe_products')
      .update(data)
      .eq('id', id)
      .select()
      .single()

    if (error) throw error
    refresh()
    return product
  }, [refresh])

  const deleteProduct = useCallback(async (id: string) => {
    await supabase
      .from('cafe_products')
      .delete()
      .eq('id', id)

    refresh()
  }, [refresh])

  const createCategory = useCallback(async (name: string) => {
    const { data: category, error } = await supabase
      .from('cafe_categories')
      .insert({
        name,
        is_visible: true,
        sort_order: 0
      })
      .select()
      .single()

    if (error) throw error
    refresh()
    return category
  }, [refresh])

  return { products, categories, loading, refresh, createProduct, updateProduct, deleteProduct, createCategory }
}

export function useAllSellers() {
  const [sellers, setSellers] = useState<(Seller & { totalSales: number; itemsSold: number })[]>([])
  const [loading, setLoading] = useState(true)

  const refresh = useCallback(async () => {
    const { data: sellersData } = await supabase
      .from('cafe_sellers')
      .select('*')
      .order('created_at', { ascending: false })

    if (sellersData) {
      const sellersWithStats = await Promise.all(
        sellersData.map(async (seller) => {
          const { data: items } = await supabase
            .from('cafe_tab_items')
            .select('quantity, unit_price')
            .eq('seller_id', seller.id)

          const itemsSold = items?.reduce((sum, i) => sum + i.quantity, 0) || 0
          const totalSales = items?.reduce((sum, i) => sum + (i.quantity * Number(i.unit_price)), 0) || 0

          return {
            ...seller,
            itemsSold,
            totalSales
          }
        })
      )
      setSellers(sellersWithStats)
    }
    setLoading(false)
  }, [])

  useEffect(() => {
    refresh()
  }, [refresh])

  const createSeller = useCallback(async (name: string, pin: string) => {
    const { data: seller, error } = await supabase
      .from('cafe_sellers')
      .insert({
        name,
        pin_hash: `hashed_${pin}`,
        is_active: true
      })
      .select()
      .single()

    if (error) throw error
    refresh()
    return seller
  }, [refresh])

  const updateSeller = useCallback(async (id: string, data: Partial<Seller>) => {
    const { data: seller, error } = await supabase
      .from('cafe_sellers')
      .update(data)
      .eq('id', id)
      .select()
      .single()

    if (error) throw error
    refresh()
    return seller
  }, [refresh])

  return { sellers, loading, refresh, createSeller, updateSeller }
}

// Reset hook (for demo purposes - just reloads the page)
export function useResetDemo() {
  const reset = useCallback(() => {
    window.location.reload()
  }, [])

  return { reset }
}

export function useOpenTab() {
  const [loading, setLoading] = useState(false)

  const openTab = useCallback(async (
    tableId: string,
    type: 'regular' | 'prepaid',
    sellerId: string,
    prepaidAmount?: number
  ): Promise<Tab> => {
    setLoading(true)

    const { data: tab, error } = await supabase
      .from('cafe_tabs')
      .insert({
        table_id: tableId,
        type,
        status: 'open',
        prepaid_amount: prepaidAmount || 0,
        balance: prepaidAmount || 0,
        tip: 0,
        created_by: sellerId
      })
      .select()
      .single()

    if (error) throw error

    // Update table to mark as occupied and link to tab
    await supabase
      .from('cafe_tables')
      .update({
        status: 'occupied',
        current_tab_id: tab.id
      })
      .eq('id', tableId)

    setLoading(false)
    return tab as Tab
  }, [])

  return { openTab, loading }
}

export function useTabByTableId(tableId: string) {
  const [tab, setTab] = useState<TabWithItemsType | null>(null)
  const [loading, setLoading] = useState(true)

  const refresh = useCallback(async () => {
    if (!tableId) {
      setLoading(false)
      return
    }

    const { data: tabData } = await supabase
      .from('cafe_tabs')
      .select(`
        *,
        cafe_tab_items (
          *,
          cafe_products (*)
        )
      `)
      .eq('table_id', tableId)
      .eq('status', 'open')
      .single()

    if (tabData) {
      const tabWithItems: TabWithItemsType = {
        id: tabData.id,
        table_id: tabData.table_id,
        type: tabData.type,
        status: tabData.status,
        total: tabData.total,
        prepaid_amount: tabData.prepaid_amount,
        balance: tabData.balance,
        tip: tabData.tip,
        paid_at: tabData.paid_at,
        created_by: tabData.created_by,
        created_at: tabData.created_at,
        tab_items: tabData.cafe_tab_items?.map((item: any) => ({
          id: item.id,
          tab_id: item.tab_id,
          product_id: item.product_id,
          seller_id: item.seller_id,
          order_id: item.order_id,
          quantity: item.quantity,
          unit_price: item.unit_price,
          created_at: item.created_at,
          product: item.cafe_products
        })) || []
      }
      setTab(tabWithItems)
    } else {
      setTab(null)
    }
    setLoading(false)
  }, [tableId])

  useEffect(() => {
    refresh()
  }, [refresh])

  const addItem = useCallback(async (productId: string, quantity: number, sellerId: string) => {
    if (!tab) return null

    // Get product price
    const { data: product } = await supabase
      .from('cafe_products')
      .select('price')
      .eq('id', productId)
      .single()

    if (!product) return null

    const { data: item, error } = await supabase
      .from('cafe_tab_items')
      .insert({
        tab_id: tab.id,
        product_id: productId,
        seller_id: sellerId,
        quantity,
        unit_price: product.price
      })
      .select()
      .single()

    if (error) throw error

    refresh()
    return item
  }, [tab, refresh])

  const closeTab = useCallback(async () => {
    if (!tab) return false

    const { error } = await supabase
      .from('cafe_tabs')
      .update({
        status: 'paid',
        paid_at: new Date().toISOString()
      })
      .eq('id', tab.id)

    if (error) return false

    // Update table to mark as available
    await supabase
      .from('cafe_tables')
      .update({
        status: 'available',
        current_tab_id: null
      })
      .eq('id', tab.table_id)

    refresh()
    return true
  }, [tab, refresh])

  return { tab, loading, refresh, addItem, closeTab }
}

// ============================================
// CLIENT-FACING HOOKS (for table QR codes)
// ============================================

// Hook to fetch table by QR code
export function useTableByQR(qrCode: string) {
  const [table, setTable] = useState<Table | null>(null)
  const [tab, setTab] = useState<Tab | null>(null)
  const [loading, setLoading] = useState(true)
  const [error, setError] = useState<string | null>(null)

  const refresh = useCallback(async () => {
    if (!qrCode) {
      setLoading(false)
      return
    }

    setLoading(true)
    const { data: tableData, error: err } = await supabase
      .from('cafe_tables')
      .select('*')
      .eq('qr_code', qrCode)
      .single()

    if (err || !tableData) {
      setError('Table not found')
      setLoading(false)
      return
    }

    setTable(tableData as Table)

    // Get active tab if exists
    if (tableData.current_tab_id) {
      const { data: tabData } = await supabase
        .from('cafe_tabs')
        .select('*')
        .eq('id', tableData.current_tab_id)
        .single()

      if (tabData) {
        setTab(tabData as Tab)
      }
    }

    setError(null)
    setLoading(false)
  }, [qrCode])

  useEffect(() => {
    refresh()
  }, [refresh])

  return { table, tab, loading, error, refresh }
}

// Hook to get tab with items for client view
export function useClientTab(tabId: string | null) {
  const [tab, setTab] = useState<TabWithItemsType | null>(null)
  const [loading, setLoading] = useState(true)

  const refresh = useCallback(async () => {
    if (!tabId) {
      setLoading(false)
      return
    }

    const { data: tabData } = await supabase
      .from('cafe_tabs')
      .select(`
        *,
        cafe_tab_items (
          *,
          cafe_products (*)
        )
      `)
      .eq('id', tabId)
      .single()

    if (tabData) {
      const tabWithItems: TabWithItemsType = {
        id: tabData.id,
        table_id: tabData.table_id,
        type: tabData.type,
        status: tabData.status,
        total: tabData.total,
        prepaid_amount: tabData.prepaid_amount,
        balance: tabData.balance,
        tip: tabData.tip,
        paid_at: tabData.paid_at,
        created_by: tabData.created_by,
        created_at: tabData.created_at,
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        tab_items: tabData.cafe_tab_items?.map((item: any) => ({
          id: item.id,
          tab_id: item.tab_id,
          product_id: item.product_id,
          seller_id: item.seller_id,
          order_id: item.order_id,
          quantity: item.quantity,
          unit_price: item.unit_price,
          created_at: item.created_at,
          product: item.cafe_products
        })) || []
      }
      setTab(tabWithItems)
    }
    setLoading(false)
  }, [tabId])

  useEffect(() => {
    refresh()
  }, [refresh])

  return { tab, loading, refresh }
}

// Hook to get categories with products for menu
export function useClientMenu() {
  const [categories, setCategories] = useState<CategoryWithProductsType[]>([])
  const [loading, setLoading] = useState(true)

  useEffect(() => {
    const fetchMenu = async () => {
      const { data } = await supabase
        .from('cafe_categories')
        .select(`
          *,
          cafe_products (*)
        `)
        .eq('is_visible', true)
        .order('sort_order')

      if (data) {
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        const formatted = data.map((cat: any) => ({
          id: cat.id,
          name: cat.name,
          sort_order: cat.sort_order,
          is_visible: cat.is_visible,
          created_at: cat.created_at,
          products: (cat.cafe_products || [])
            .filter((p: Product) => p.is_active)
            .sort((a: Product, b: Product) => a.sort_order - b.sort_order)
        }))
        setCategories(formatted)
      }
      setLoading(false)
    }

    fetchMenu()
  }, [])

  return { categories, loading }
}

// Hook to create order and add items to tab
export function useCreateOrder(tabId: string | null) {
  const [loading, setLoading] = useState(false)

  const createOrder = useCallback(async (items: { product_id: string; quantity: number; notes?: string }[]) => {
    if (!tabId) return null

    setLoading(true)

    // Create order
    const { data: order, error: orderError } = await supabase
      .from('cafe_orders')
      .insert({
        tab_id: tabId,
        status: 'pending',
        notes: null
      })
      .select()
      .single()

    if (orderError || !order) {
      setLoading(false)
      throw new Error('Failed to create order')
    }

    // Add order items
    const orderItems = items.map(item => ({
      order_id: order.id,
      product_id: item.product_id,
      quantity: item.quantity,
      notes: item.notes || null
    }))

    const { error: itemsError } = await supabase
      .from('cafe_order_items')
      .insert(orderItems)

    if (itemsError) {
      setLoading(false)
      throw new Error('Failed to add order items')
    }

    // Add to tab items
    const tabItemsData = await Promise.all(
      items.map(async (item) => {
        // Get product price
        const { data: product } = await supabase
          .from('cafe_products')
          .select('price')
          .eq('id', item.product_id)
          .single()

        return {
          tab_id: tabId,
          product_id: item.product_id,
          seller_id: null,
          order_id: order.id,
          quantity: item.quantity,
          unit_price: product?.price || 0
        }
      })
    )

    await supabase
      .from('cafe_tab_items')
      .insert(tabItemsData)

    setLoading(false)
    return order
  }, [tabId])

  return { createOrder, loading }
}

// Hook to send notifications
export function useSendNotification() {
  const [loading, setLoading] = useState(false)

  const sendNotification = useCallback(async (
    type: 'order' | 'bill_request' | 'server_call' | 'payment' | 'refund_request' | 'low_balance',
    tableId: string,
    message: string
  ) => {
    setLoading(true)

    const { error } = await supabase
      .from('cafe_notifications')
      .insert({
        type,
        table_id: tableId,
        seller_id: null,
        message,
        read: false
      })

    setLoading(false)
    if (error) throw error
  }, [])

  return { sendNotification, loading }
}
